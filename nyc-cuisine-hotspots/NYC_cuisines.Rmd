---
title: "NYC Cuisine Hotspots"
author: "Evan Powell"
date: "2025-08-08"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
# Load packages
library(tidyverse)
library(janitor)
library(sf)
library(dbscan)
library(tmap)
library(leaflet)
library(tidycensus)
library(tigris)
library(skimr)
library(RSocrata)
library(RColorBrewer)

```

```{r reading nyc data}
#read data from NYC Open Data
restaurants <- read.socrata(
  "https://data.cityofnewyork.us/resource/43nn-pn8j.json",
  app_token = Sys.getenv("SOCRATA_APP_TOKEN"),
  email     = Sys.getenv("SOCRATA_EMAIL"),
  password  = Sys.getenv("SOCRATA_PASSWORD")
)
```

``` {r local save}
saveRDS(restaurants, "restaurants.rds")

```
```{r local retrieve}
restaurants <- readRDS("restaurants.rds")
```

```{r clean data}
#Remove columns we don't need
restaurants <- restaurants %>%
  select(camis, dba, cuisine_description, latitude, longitude)

#Make numeric the Lat / Long.
restaurants <- restaurants %>%
  mutate(
    latitude = as.numeric(latitude),
    longitude = as.numeric(longitude)
  )

#drop rows without Lat / Long. or cuisine description
restaurants <- restaurants %>%
  filter(
    !is.na(latitude),
    !is.na(longitude),
    !is.na(cuisine_description)
  )

#deduplicate
restaurants_unique <- restaurants %>%
  distinct(camis, .keep_all = TRUE)
```

```{r listing cuisines}
list_cuisines <- function(data) {
  data %>%
    group_by(cuisine_description) %>%
    summarise(n = n(), .groups = "drop") %>%
    arrange(desc(n))
}

cuisine_counts <- list_cuisines(restaurants_unique)
```


```{r clustering}
run_dbscan_for_cuisine <- function(data, cuisine, eps = 0.005, minPts = 5) {
 # 1. Filter for the chosen cuisine and remove null island coords
  cuisine_data <- data %>%
    filter(
      cuisine_description == cuisine,
      !is.na(latitude),
      !is.na(longitude),
      latitude != 0,
      longitude != 0
    )
 # 2. Prepare coordinates matrix
  coords <- cuisine_data %>%
    select(longitude, latitude) %>%
    as.matrix()
  # 3. Run DBSCAN
  db_result <- dbscan::dbscan(coords, eps = eps, minPts = minPts)
  # 4. Add cluster assignments back to data
  cuisine_data <- cuisine_data %>%
    mutate(cluster = db_result$cluster)
  
  return(cuisine_data)
}

run_dbscan_for_cuisine_auto <- function(data, cuisine, eps = 0.005, min_floor = 3, prop_factor = 0.02) {
 # 1. Filter for the chosen cuisine and remove null island coords
  cuisine_data <- data %>%
    filter(
      cuisine_description == cuisine,
      !is.na(latitude),
      !is.na(longitude),
      latitude != 0,
      longitude != 0
    )
  
  total_count <- nrow(cuisine_data)
  if (total_count == 0) {
    warning("No restaurants found for cuisine: ", cuisine)
    return(NULL)
  }
  
  # 2. Calculate minPts dynamically
  minPts <- max(min_floor, round(total_count * prop_factor))
    
 # 3. Prepare coordinates matrix
  coords <- cuisine_data %>%
    select(longitude, latitude) %>%
    as.matrix()
  # 3. Run DBSCAN
  db_result <- dbscan::dbscan(coords, eps = eps, minPts = minPts)
  # 5. Add cluster assignments back to data
  cuisine_data <- cuisine_data %>%
    mutate(cluster = db_result$cluster)
  
  # Attach settings used
  attr(cuisine_data, "dbscan_params") <- list(
    eps = eps,
    minPts = minPts,
    total_count = total_count
  )
  
  return(cuisine_data)
}

```

``` {r mapping}
map_dbscan_clusters <- function(clustered_data) {
  
  clustered_data <- clustered_data %>%
    filter(latitude != 0, longitude != 0) %>%
    mutate(cluster = as.factor(cluster))
  
  clustered_sf <- st_as_sf(
    clustered_data,
    coords = c("longitude", "latitude"),
    crs = 4326,   # WGS84 lat/long
    remove = FALSE
  )
  
  # Dynamically create enough colors for the number of clusters
  num_clusters <- length(unique(clustered_sf$cluster))
  colors <- brewer.pal(
    n = max(3, min(12, num_clusters)),  # palettes max out at 12 colors
    name = "Set1"
  )
  
  tmap_mode("view")  # interactive mode
  
  tm_shape(clustered_sf) +
    tm_dots(
      col = "cluster",        # color by cluster ID
      palette = colors,       # distinct colors
      size = 0.55,            # small points
      alpha = 0.7,            # semi-transparent
      title = "Cluster ID"
    ) +
    tm_layout(legend.outside = TRUE)
  
}
```

``` {r example Caribbean}
caribbean_clusters <- run_dbscan_for_cuisine(
  data = restaurants_unique,
  cuisine = "Caribbean",
  eps = 0.0075,  
  minPts = 5
)

head(caribbean_clusters)

map_dbscan_clusters(caribbean_clusters)
```


``` {r example Chinese}
chinese_clusters <- run_dbscan_for_cuisine(
  data = restaurants_unique,
  cuisine = "Chinese",
  eps = 0.005,  
  minPts = 9
)


map_dbscan_clusters(chinese_clusters)
```

``` {r example any}

test_cuisine = "Peruvian"

test_cuisine_clusters <- run_dbscan_for_cuisine_auto(
  data = restaurants_unique,
  cuisine = test_cuisine,
  eps = 0.007,  
  min_floor = 4,
  prop_factor = 0.01
)


map_dbscan_clusters(test_cuisine_clusters)
```


## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
